---
layout: post
title: "Power of Closure"
date: 2013-01-03 18:31
comments: true
keywords: "closure, lisp, callback"
categories: closure
---
To begin with closure, let's take a quick look at scope.

What is Scope ? It deifnes the environemnt or area where variables or functions are available. Suppose we have a method `foo()`
and we create a variable `x` inside `foo()` . <br />
So it is clear that the variable `x` is only available inside `foo()` (unless explicitly defined as global).
Now let's think, there is another function that wants to use this local variable `x` or the other way let me say the other function wants to use the state of function `foo()`.

How to do this ?

Look at this image.<br />
<a href="http://s1290.beta.photobucket.com/user/skypya/media/Blog/closure_zps340b5344.jpg.html" target="_blank"><img src="http://i1290.photobucket.com/albums/b521/skypya/Blog/closure_zps340b5344.jpg" border="0" alt="Photobucket"/></a>

Let me explain the image with a small example in lisp.
{% codeblock %}
(defun foo(x)
       (defun bar(n) (+ n x)))
{% endcodeblock %}

In the code `foo()` points to the outer region in the image and `bar()` is the inner region. Notice `x` is actually in the scope of `foo()`. However the inner method `bar()` has access to the variable `x`. This is closure. *The inner region is associated with an
environment that is the outer region*.<br />
The vairable `x` is a free varible and accessible to `foo()` and `bar()`. Interesting fact is that there will be no problem to acccess the free variable `x` inside the method `bar()` even though the outher method `foo()` is returned.

Converting the above code to use an annonymous function.
{% codeblock %}
(defun foo(x)
       #' (lambda (x) (+ x 10)))
{% endcodeblock %}

Both of the above codes are creating closure - one with named function and the other with
annonymous function. Note that we frequently use annonymous function but that doesn't mean it is creating a closure. The function must require an environment to form a closure
same as the way a named function does.

There are different languages which support closure, for example, Lisp, Javascirpt, pyhton. And there are languages which do not support Closure, examples are C, C++, Java.

Let me write a small code in pyhton that has closure.
{% codeblock %}
def outer(num1, num2):
  def inner(num):
    return num + num1 + num2
  return inner
{% endcodeblock %}

If we call the above function `outer(2, 3)(10)`, it will output `15`.

Now, Let's output the same result using a *callback* function.
{% codeblock %}
def foo(num1, num2, callback):
    n = num1 + num2
    return callback(n)
{% endcodeblock %}

Calling the function `foo()` with the arguments `num1`, `num2` and a callback function
using *lambda*.
{% codeblock %}
foo(2, 3, lambda x : x + 10)
{% endcodeblock %}
The outout is `15`.

So here is the question. How is closure different from a callback function?
If we generalize the question, it would be - *how is closure different from the
similar techniques available in other languages which do not support closure, for
example, function pointer in C, annonymous inner class in java*?

The main difference is, in the above example the method `inner` knows that it came from the method `outer`, that is, `inner` has idea of it's environment. But callback is not. It is just a *block of executable code which can be passed as an argument to other function*.

See also <br />
1. [Closure](http://martinfowler.com/bliki/Closure.html) <br />
2. [Closure and inner class](http://www.javaworld.com/javaworld/jw-06-2008/jw-06-closures.html)